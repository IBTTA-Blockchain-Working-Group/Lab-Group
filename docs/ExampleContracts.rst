
Sample Contracts
===============

Introduction
----------------

We show some of the contracts that are based on documentation generated by the Tolling and Customer Service Working Group. We look at the webservices described in the document as a basis for defining the libraries and the contracts.


AgencyLib
------------

.. code:: ocaml

  scilla_version 0

  import BoolUtils

  library AgencyLib
   (**
   Library design based on the Tolling and Customer Service
   Working Group's ICD document.
   *)

  type Agency =  | Agency of String
  type LPState = | LPState of String
  type LPCounty = | LPCount of String
  type TollOperator = | TollOperator of String
  type AccountManagement = | MobileApp | TransponderDistributor | TransponderRetail
  type AccountTool = | Smartphone | CustomerServiceCenter | MobileAppTool
  type AccountIdentifier = | VehicleLicensePlate | TransponderIdentifier
  type InitialTerm = | InitialTerm of Uint32
  type RenewTerm = | RenewTerm of Uint32
  type ContractorCompensation = | ContractorCompensation of Uint32

  (** Exhibit B : Costs - not to exceed the costs listed *)

  type ProductCost = | ProductCost of Uint64
  type PreLoadedTolls = | PreLoadedTolls of Uint64
  type TransponderCost = | TransponderCost of Uint64
  type AppDownloadCost = | AppDownloadCost of Uint64
  type ReloadFees = | ReloadFees of Uint64


TagActivationRequestLib
------------------------

.. code:: ocaml

  scilla_version 0

  import BoolUtils

  library TagActivationRequestLib

  type TagChangeRequest = | TagActivation | TagDeactivation | TagSuspension | Occupancy
  (* Should print as Y or N *)
  type DispositionStatus = | Active | NotActive
  type DispositionNote = | DispositionNote of String

  (* A 20 character tag id string *)
  type TagID = | TagID of String
  type LPType = | AllTerrain | Ambulance | CampTrailer | Camper | Combination
                | Commercial | CongressionalMedalOfHonor
                | Construction | Dealer
                | ExperimentalTest | Factory | Farm
                | FireApparatus | GeneralDistrictBus
                | Handicapped | HandicappedMotorcycle
                | Hearse | Historical | Interstate
                | Legislature | Livery | Motorcycle
                | Municipal | Passenger | Permits | POW_CMPR
                | POW_COMB | POW_Veteran | PublicServiceBus
                | SchoolBus | SchoolBusLivery | Senate
                | ServiceBus | Snowmobile | SpecialMobileEquip
                | StateVehicle | StateServBus | StateSTV



  type VehicleOccupancy = | VehicleOccupancy of Uint32
  type VehicleClass = | VehicleClass of Uint32 (* Any number between 2 - 6 axles *)
  type VehicleStatus = | Valid | Invalid (* Valid = 0, Invalid = 2 *)
  type FacilityCode = | FacilityCode of String
  type PlazaCode = | PlazaCode of String
  type LaneCode = | LaneCode of String
  type TransactionTime = | TransactionTime of Uint64
  type LPNumber = | LPNumber of String
  type PostFareAmount = | PostFareAmount of Uint128 (* Number of zil/microzils for the fare *)


Notes about contracts
----------------------

The development of an application centered around the libraries and contracts will most likely involve interaction between a web application or a mobile application to execute contracts by passing parameters from the application. Additional details about the contract structure can be found `Learn Scilla <https://scilla.readthedocs.io/en/latest/intro.html>`_. Notable part of the structure is the *events* that can be published to monitor change in the contract. The documentation on the Scilla site is quite extensive to help the interested reader. 


Account Management Smart Contract
------------------------------------

.. code:: ocaml

  scilla_version 0
  (* Imports *)
  import BoolUtils AgencyLib

  (**
   A third-party account management contract to on board a third-party vendor.
  *)
  contract AccountManagement(thirdParty: ByStr20)
    field state : String = ""
    field county : String = ""
    field termLimit : Uint64 = Uint64 0
    field tagActivationRequest : TagChangeRequest = TagActivation

    transition setAgency(inputAgency : Agency) 
      agency := inputAgency
    end
    transition setTermLimit (aNumber : Uint64)
      termLimit := aNumber
    end

    transition getTermLimit ()
      r <- termLimit;
      e  = { _eventname: "TermLimit"; msg : r};
      event e
    end


Tag Activation Request Contract
--------------------------------

.. code:: ocaml

(** Tag activation request *)

scilla_version 0

import BoolUtils TagActivationRequestLib AgencyLib

(* Assumptions: Each home agency instantiates this contract for away agency tag change request. This
might change if we appoint a central authority that manages all of these tag change requests. *)

contract TagChangeRequestContract (agency : Agency)
  field tagAgency : Agency =
    let empty = "" in
    Agency empty
  field tagID : TagID =
    let empty = "" in
      TagID empty
  field lpState : LPState =
    let empty = "" in
      LPState empty
  field lpNumber : LPNumber = let empty = "" in LPNumber empty
  field lpType : LPType = Passenger (* default *)
  field vehicleOccupancy : VehicleOccupancy = let defValue = Uint32 4 in VehicleOccupancy defValue (* Another default *)
  field vehicleClass : VehicleClass = let defValue = Uint32 2 in VehicleClass defValue (* a sedan *)
  field requestType : TagChangeRequest = TagActivation (* Default *)
  field requestNote : String = "Enter the notes for this request here"
  (* Transitions need to be checked for owner so that the requests are originating from a list of valid
  agencies. *)

  transition SetTagAgency(aTagAgency : Agency)
    tagAgency := aTagAgency; (* check this is not the same as the home agency *)
    updateTagAgencyEvent = {_eventname : "SetTagAgency"; msg : "Updated tag agency" ; agency : aTagAgency};
    event updateTagAgencyEvent
  end

  transition SetTagID(anInput : TagID)
    tagID := anInput;
    updateTagID = {_eventname : "SetTagID"; msg : "Updated Tag ID"; tagid : anInput};
    event updateTagID
  end

  transition SetLpState(anInput : LPState)
    lpState := anInput;
    updateLpState = {_eventname : "SetLpState"; msg :  "Updated LpState"; state : anInput};
    event updateLpState
  end

  transition SetLpNumber(anInput : LPNumber)
    lpNumber := anInput;
    updateLpNumber = {_eventname : "SetLpNumber"; msg : "Update LpNumber"; lpnumber : anInput};
    event updateLpNumber
  end

  transition SetLpType(anInput : LPType)
    lpType := anInput;
    updateLpType = {_eventname : "SetLpType"; msg : "Update License Plate Type"; lptype : anInput};
    event updateLpType
  end

  transition SetVehicleClass(anInput : VehicleClass)
    vehicleClass := anInput;
    updateVehicleClass = {_eventname : "SetVehicleClass"; msg : "Update vehicle class"; vehicleclass : anInput};
    event updateVehicleClass
  end

  transition SetVehicleOccupancy(anInput : VehicleOccupancy)
    vehicleOccupancy := anInput;
    updateVehicleOccupancy = {_eventname : "SetVehicleOccupancy"; msg : "Update vehicle occupancy"; occupancy  : anInput};
    event updateVehicleOccupancy
  end

  transition SetRequestType(anInput : TagChangeRequest)
    requestType := anInput;
    updateRequestType = {_eventname : "SetRequestType"; msg : "Update request type" ; requesttype : anInput};
    event updateRequestType
  end


  transition SetRequestNote(anInput : String)
    requestNote := anInput;
    updateRequestNote = {_eventname : "SetRequestNote"; msg : "Update request note"; requestnote : anInput};
    event updateRequestNote
  end



Toll State Guarantee
------------------------

This contract explores the risk attributed during the time window for claiming a toll between a *home agency* and an *away agency*. An aspect of computing risk that we would like to explore in this contract is to use *continuous compounding* and compute risk at intervals rather than fixed time intervals such as week, month etc. 

*Refactoring note: Move the library code to a .scillib file*

.. code:: ocaml
(* Scilla contract structure *)

scilla_version 0

(* Imports *)

import BoolUtils

(* Library *)

library TollStateGuarantee
  (* Interest rate in percent. This needs to be read from the local exchange rate*)
  let annualizedInterestRate = Uint32 1
  let minimumTimeInterval = Uint32 60 (* Interval in minutes*)
  type SupportedProtocol = 
    | IAG
    | NIOP

  (* Scilla doesn't allow for floating point computations to maintain the security of the language. But it does support Uint64 integer types. Therefore we need to resort to expressing compounding formula in terms of natural numbers.*) 

  type Timestamp = | Timestamp of Uint64


  let initTimestamp : Uint64 -> Timestamp =
    fun (initTime : Uint64) => Timestamp initTime

  (* Toll Guarantee Interval *)
  let tollGuaranteeInterval : Timestamp =
    let nH = Uint64 4 in 
    let nS = Uint64 3600 in
    let numHours = builtin mul nH nS in
    initTimestamp numHours

  let timeInterval : Timestamp -> Timestamp -> Timestamp =
    fun (startTime : Timestamp) => 
    fun (endTime : Timestamp) =>
    match startTime with
      | Timestamp s =>
        match endTime with
          | Timestamp e => 
            let d = builtin sub e s
            in 
              Timestamp d
      end
    end

  let addTimestamp : Timestamp -> Timestamp -> Timestamp =
    fun (t1 : Timestamp) =>
    fun (t2 : Timestamp) => 
      match t1 with
        | Timestamp t11 =>
          match t2 with
           |Timestamp t12 =>
            let t13 = builtin add t11 t12 in
            Timestamp t13
          end
      end

  let timeExpired : Timestamp -> Timestamp -> Timestamp -> Bool =
    fun (startTime : Timestamp) =>
    fun (currentTime : Timestamp) =>
    fun (timeInterval : Timestamp) => 
      match startTime with 
        | Timestamp s => 
          match currentTime with
            | Timestamp c =>
                let d = addTimestamp startTime timeInterval in
                let zero = Uint64 0
                in
                  match d with
                    |Timestamp d2 => builtin lt d2 c
                  end
          end
      end

  let eulerConstant = "2.71828182845904523536028747135266249775724709369995"

  (*
    The formula for continuous compounding is 
      A = P * (eulerConstant ^ (rate * timeIntervals)). 
    However, since scilla prevents using floating point numbers, these numbers will need to be converted to integers and then rounded down. TBD.
  *)
  let continuousCompounding : Uint64 -> Timestamp -> Timestamp -> Uint64 = 
  fun (interestRate : Uint64) =>
  fun (startTime : Timestamp) =>
  fun (currentTime : Timestamp) =>
    Uint64 0

(* ********************* Contract definition ****************************************************
  * This contract represents the state machine for providing* 
  * guarantee for collection of a toll during inter-state travel.* 
  * The guarantee depends on the protocol that agencies support. * 
  * If the agency supports NIOP protocol, then the guarantee is waived. * 
  * However, if the agency supports IAG then the timer for acquiring the risk starts, typically, 4 * hours. 
  * If the AwayAgency accepts the risk, then the risk is allocated to the Away Agency. * 
  However, if the timer expires, the Home Agency accepts the risk. This risk gets added to risk of toll * collection for the time period. * 
  Note: time period in a distributed, blockchain environment may not align calendar events such as days, * weeks, years, therefore, * 
  * we propose that the risk be computed using * 
  * continuous compounding with an annualized rate * 
  * of interest for the time line. We decide to use * 
  * 60 minutes as the minimum time interval.  * 

**********************************************************************************)

contract TollStateGuarantee
  (* Parameters *)
  (homeAgency: ByStr20,
    awayAgency : ByStr20,
    guaranteeGracePeriod : Timestamp,
    riskAmount : Uint64)
with
  let zero = Uint64 0 in
  builtin lt zero riskAmount
  => 
  field tagId : String = ""
  field startTime : Timestamp
    = let
        zero = Uint64 0 in
      Timestamp zero
